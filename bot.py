import discord
from discord.ext import commands
from discord import app_commands
import json
import pytz
londyn = pytz.timezone("Europe/London")
from datetime import datetime, timedelta, time  # dodaj te≈º `time`
import asyncio
import random

# üåÄ GODZINA CHAOSU
godzina_chaosu = None  # zaplanowana godzina
aktywny_chaos = False  # czy aktualnie trwa

cooldowns_kurier = {}  # {user_id: datetime}
from discord.ui import View, Button

intents = discord.Intents.default()
intents.message_content = True
bot = commands.Bot(command_prefix="!", intents=intents)
tree = bot.tree

# Wczytywanie danych
try:
    with open("dane.json", "r") as f:
        user_data = json.load(f)
except FileNotFoundError:
    user_data = {}

try:
    with open("cooldowns.json", "r") as f:
        cooldowns = json.load(f)
except FileNotFoundError:
    cooldowns = {}

def init_user(uid):
    default = {
        "punkty": 0,
        "cenna": 0,
        "green": 0,
        "blue": 0,
        "white": 0,
        "spisek": 0,
        "kable": 0,
        "capt": 0
    }
    if uid not in user_data:
        user_data[uid] = default.copy()
    elif isinstance(user_data[uid], dict):
        for key in default:
            if key not in user_data[uid]:
                user_data[uid][key] = default[key]

def can_use_command(uid, command):
    now = datetime.utcnow()
    user_cd = cooldowns.get(uid, {})
    last_used_str = user_cd.get(command)
    cooldown_hours = {"cenna": 24, "kable": 24, "spisek": 30}.get(command, 24)
    if last_used_str:
        last_used = datetime.strptime(last_used_str, "%Y-%m-%d %H:%M:%S")
        if now - last_used < timedelta(hours=cooldown_hours):
            remaining = timedelta(hours=cooldown_hours) - (now - last_used)
            return False, remaining
    return True, None

def update_cooldown(uid, command):
    now = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S")
    if uid not in cooldowns:
        cooldowns[uid] = {}
    cooldowns[uid][command] = now
    with open("cooldowns.json", "w") as f:
        json.dump(cooldowns, f)

def kontrakt_embed(user, typ, emoji, kolor):
    teraz = datetime.now().strftime("%d.%m.%Y, %H:%M:%S")
    return discord.Embed(
        title=f"{emoji} Kontrakt Zako≈Ñczony",
        description=f"Kontrakt **{typ}** zako≈Ñczony przez {user.mention}.\nüìÖ **Data:** {teraz}",
        color=kolor
    )

lottery_participants = {}
lottery_messages = {}

def save_lottery_data():
    with open("loteria.json", "w") as f:
        json.dump({
            "participants": {str(k): list(v) for k, v in lottery_participants.items()},
            "messages": {str(k): v for k, v in lottery_messages.items()}
        }, f)

def load_lottery_data():
    global lottery_participants, lottery_messages
    try:
        with open("loteria.json", "r") as f:
            data = json.load(f)
            lottery_participants = {int(k): set(v) for k, v in data.get("participants", {}).items()}
            lottery_messages = {int(k): v for k, v in data.get("messages", {}).items()}
    except FileNotFoundError:
        pass

async def zakoncz_kontrakt(interaction, typ, punkty, klucz, emoji, kolor, cooldown=False):
    user = interaction.user
    uid = str(user.id)
    init_user(uid)

    if cooldown:
        allowed, wait_time = can_use_command(uid, klucz)
        if not allowed:
            h, rem = divmod(wait_time.total_seconds(), 3600)
            m = int(rem // 60)
            await interaction.response.send_message(f"‚è≥ Odczekaj **{int(h)}h {m}min**.", ephemeral=True)
            return
        update_cooldown(uid, klucz)

    user_data[uid]["punkty"] += punkty
    user_data[uid][klucz] += 1
    with open("dane.json", "w") as f:
        json.dump(user_data, f)

    embed = kontrakt_embed(user, typ, emoji, kolor)
    await interaction.response.send_message(embed=embed)
    await odswiez_statystyki(interaction.guild)

from discord.ext import commands

from datetime import datetime, timedelta

@tree.command(name="kuriergreen", description="Zako≈Ñcz kontrakt green (+1 pkt)")
async def green(interaction: discord.Interaction):
    uid = str(interaction.user.id)
    teraz = datetime.utcnow()

    ostatni = cooldowns_kurier.get(uid)
    if ostatni and teraz - ostatni < timedelta(minutes=15):
        pozostalo = timedelta(minutes=15) - (teraz - ostatni)
        minuty, sekundy = divmod(pozostalo.total_seconds(), 60)
        await interaction.response.send_message(
            f"‚è≥ Mo≈ºesz ponownie u≈ºyƒá tej komendy za **{int(minuty)}m {int(sekundy)}s**.",
            ephemeral=True
        )
        return

    cooldowns_kurier[uid] = teraz
    punkty = 3 if aktywny_chaos else 1
    await zakoncz_kontrakt(interaction, "kurier_green", punkty, "green", "üåø", 0x00ff00)


@tree.command(name="kurierblue", description="Zako≈Ñcz kontrakt blue (+1 pkt)")
async def blue(interaction: discord.Interaction):
    uid = str(interaction.user.id)
    teraz = datetime.utcnow()

    ostatni = cooldowns_kurier.get(f"blue_{uid}")
    if ostatni and teraz - ostatni < timedelta(minutes=15):
        pozostalo = timedelta(minutes=15) - (teraz - ostatni)
        minuty, sekundy = divmod(pozostalo.total_seconds(), 60)
        await interaction.response.send_message(
            f"‚è≥ Mo≈ºesz ponownie u≈ºyƒá tej komendy za **{int(minuty)}m {int(sekundy)}s**.",
            ephemeral=True
        )
        return

    cooldowns_kurier[f"blue_{uid}"] = teraz
    punkty = 3 if aktywny_chaos else 1
    await zakoncz_kontrakt(interaction, "kurier_blue", punkty, "blue", "üíô", 0x3498db)


@tree.command(name="kurierwhite", description="Zako≈Ñcz kontrakt white (+1 pkt)")
@commands.cooldown(1, 900, commands.BucketType.user)
async def white(interaction: discord.Interaction):
    punkty = 3 if aktywny_chaos else 1
    await zakoncz_kontrakt(interaction, "kurier_white", punkty, "white", "ü§ç", 0xffffff)

@tree.command(name="cenna", description="Rozpocznij kontrakt cenna (grupowy, min. 2 osoby)")
async def cenna(interaction: discord.Interaction):
    view = CennaKontraktView(interaction, interaction.guild.id)
    msg = await interaction.channel.send(
        content=f"üî´ **Kontrakt CENNA rozpoczƒôty przez {interaction.user.mention}!**\n"
                f"Kliknij przycisk, aby do≈ÇƒÖczyƒá do kontraktu. Potrzeba minimum 2 os√≥b.",
        view=view
    )
    view.kontrakt_msg = msg 
    active_cenna_contracts[interaction.guild.id]["msg_id"] = msg.id
    await interaction.response.send_message("üìå Kontrakt cenna zosta≈Ç utworzony!", ephemeral=True)

@tree.command(name="spisek", description="Rozpocznij grupowy spisek (tylko dla leader√≥w i zarzƒÖdu)")
async def spisek(interaction: discord.Interaction):
    # Sprawd≈∫ role
    role_names = [role.name.lower() for role in interaction.user.roles]
    if "leader" not in role_names and "zarzƒÖd" not in role_names:
        await interaction.response.send_message("‚ùå Tylko u≈ºytkownicy z rolƒÖ `leader` lub `zarzƒÖd` mogƒÖ rozpoczƒÖƒá spisek.", ephemeral=True)
        return

    # Rozpocznij spisek
    view = SpisekKontraktView(interaction, interaction.guild.id)
    msg = await interaction.channel.send(
        f"üß† **Rozpoczƒôto kontrakt spisek!**\nInicjator: {interaction.user.mention}\nZalecane min. 2 osoby.",
        view=view
    )
    view.kontrakt_msg = msg
    active_spisek_contracts[interaction.guild.id]["msg_id"] = msg.id
    await interaction.response.send_message("Spisek zosta≈Ç aktywowany!", ephemeral=True)

@tree.command(name="kable", description="Rozpocznij kontrakt grupowy kable")
async def start_kable(interaction: discord.Interaction):
    view = KableKontraktView(interaction, interaction.guild.id)
    info = (
        f"üë• Zapisani (1/5): {interaction.user.mention}\n"
        f"üïê Potrzeba jeszcze **4** os√≥b do rozpoczƒôcia kontraktu."
    )
    message = await interaction.channel.send(f"üì¶ **Kontrakt grupowy: kable**\n{info}", view=view)
    kontrakt = active_kable_contracts[interaction.guild.id]
    kontrakt["msg_id"] = message.id
    kontrakt["message"] = message
    await interaction.response.send_message("üöÄ Kontrakt grupowy **kable** zosta≈Ç rozpoczƒôty!", ephemeral=True)

# --- Statystyki i UI ---
def generuj_raport(user_data):
    emoji_map = {
        "green": "üåø green",
        "blue": "üíô blue",
        "white": "ü§ç white",
        "cenna": "üî´ cenna",
        "spisek": "üß† spisek",
        "kable": "üì¶ kable",
        "capt": "‚öîÔ∏è capt",
    }

    ranking = sorted(user_data.items(), key=lambda x: x[1]["punkty"], reverse=True)
    lines = []
    for i, (uid, data) in enumerate(ranking):
        if data["punkty"] <= 0:
            continue

        # Dob√≥r emoji w zale≈ºno≈õci od miejsca
        if i == 0:
            prefix = "ü•á"
        elif i == 1:
            prefix = "ü•à"
        elif i == 2:
            prefix = "ü•â"
        else:
            prefix = "üë§"

        aktywne = [f"{emoji_map[k]}: {v}" for k, v in data.items() if k in emoji_map and v > 0]
        aktywnosci_text = " | ".join(aktywne)

        linia = (
            "‚îÅ\n"
            f"{prefix} **<@{uid}>**\n"
            f"{aktywnosci_text}\n"
            f"üî¢ **Suma punkt√≥w:** {data['punkty']}"
        )
        lines.append(linia)

    return f"üìà **STATYSTYKI AKTYWNO≈öCI**\n\n" + "\n".join(lines)

class ResetModal(discord.ui.Modal, title="Reset Statystyk"):
    kod = discord.ui.TextInput(label="Wpisz kod resetu", placeholder="kod", required=True)

    async def on_submit(self, interaction: discord.Interaction):
        if self.kod.value == "heaven2025":
            user_data.clear()
            with open("dane.json", "w") as f:
                json.dump(user_data, f)

            kanal = discord.utils.get(interaction.guild.text_channels, name="‚úÖ‚îÉstatystyki")
            if kanal:
                async for msg in kanal.history(limit=10):
                    await msg.delete()
                raport_txt = generuj_raport(user_data)
                await kanal.send(raport_txt, view=StatystykiView(raport_txt))

            await interaction.response.send_message("‚úÖ Statystyki zosta≈Çy zresetowane!", ephemeral=True)
        else:
            await interaction.response.send_message("‚ùå Nieprawid≈Çowy kod.", ephemeral=True)

class StatystykiView(discord.ui.View):
    def __init__(self, raport):
        super().__init__(timeout=None)
        self.raport = raport

    @discord.ui.button(label="üìÅ Pobierz raport", style=discord.ButtonStyle.primary)
    async def download_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        with open("statystyki_aktywnosci.txt", "w", encoding="utf-8") as f:
            f.write(self.raport)
        await interaction.response.send_message("üìé Pobierz plik:", file=discord.File("statystyki_aktywnosci.txt"), ephemeral=True)

    @discord.ui.button(label="üîÑ Resetuj statystyki", style=discord.ButtonStyle.danger)
    async def reset_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(ResetModal())

@tree.command(name="statystyki", description="Utw√≥rz lub zaktualizuj statystyki aktywno≈õci")
async def statystyki(interaction: discord.Interaction):
    raport_txt = generuj_raport(user_data)

    kanal = discord.utils.get(interaction.guild.text_channels, name="‚úÖ‚îÉstatystyki")
    if kanal is None:
        kanal = await interaction.guild.create_text_channel("‚úÖ‚îÉstatystyki")

    async for msg in kanal.history(limit=10):
        await msg.delete()

    if len(raport_txt) > 6000:
        raport_txt += "\n\n[‚ö†Ô∏è Uwaga: ko≈Ñc√≥wka raportu mog≈Ça zostaƒá obciƒôta z powodu limitu Discorda]"

    for i in range(0, len(raport_txt), 1880):
        await kanal.send(raport_txt[i:i+1880])


    # Potem osobno przyciski
    await kanal.send(view=StatystykiView(raport_txt))

    await interaction.response.send_message("üìä Statystyki zosta≈Çy opublikowane!", ephemeral=True)

async def odswiez_statystyki(guild):
    kanal = discord.utils.get(guild.text_channels, name="‚úÖ‚îÉstatystyki")
    if kanal:
        async for msg in kanal.history(limit=10):
            await msg.delete()

        raport_txt = generuj_raport(user_data)

        # Wysy≈Çanie raportu partiami
        if len(raport_txt) > 6000:
            raport_txt += "\n\n[‚ö†Ô∏è Uwaga: ko≈Ñc√≥wka raportu mog≈Ça zostaƒá obciƒôta z powodu limitu Discorda]"

        for i in range(0, len(raport_txt), 1880):
            await kanal.send(raport_txt[i:i+1880])

        # Potem same przyciski
        await kanal.send(view=StatystykiView(raport_txt))

import asyncio
from discord.ui import View, Button
import discord
import json

active_kable_contracts = {}  # {guild_id: {"inicjator": user, "uczestnicy": set, "msg_id": id, "message": msg_obj}}

async def przypomnienie_kable(guild):
    kontrakt = active_kable_contracts.get(guild.id)
    if not kontrakt:
        return

    kanal = discord.utils.get(guild.text_channels, name="üéØ‚îÉkontrakty-aktywno≈õƒá")
    if not kanal:
        return

    for i in range(3):
        if guild.id not in active_kable_contracts:
            break
        pozostali = 5 - len(kontrakt["uczestnicy"])
        if pozostali <= 0:
            break

        await kanal.send(
            f"@everyone üì¶ Kontrakt **Kable** aktywny!\n"
            f"Potrzeba jeszcze **{pozostali}** os√≥b do zamkniƒôcia kontraktu.\n"
            f"Kliknij powy≈ºej przycisk **Zapisz siƒô na kable**, je≈õli ju≈º fizycznie dostarczy≈Çe≈õ kabel. üì•"
        )
        await asyncio.sleep(20 * 60)

class KableKontraktView(View):
    def __init__(self, interaction, guild_id):
        super().__init__(timeout=None)
        self.guild_id = guild_id
        self.inicjator = interaction.user
        kontrakt = {
            "inicjator": self.inicjator,
            "uczestnicy": set([self.inicjator.id]),
            "msg_id": None,
            "message": None
        }
        active_kable_contracts[guild_id] = kontrakt
        asyncio.create_task(przypomnienie_kable(interaction.guild))

    async def update_message(self, channel):
        kontrakt = active_kable_contracts[self.guild_id]
        uczestnicy = kontrakt["uczestnicy"]
        message = kontrakt.get("message")

        mentions = ", ".join(f"<@{uid}>" for uid in uczestnicy)
        info = (
            f"üë• Zapisani ({len(uczestnicy)}/5): {mentions}\n"
            f"üïê Potrzeba jeszcze **{max(0, 5 - len(uczestnicy))}** os√≥b do rozpoczƒôcia kontraktu."
        )

        if message:
            try:
                await message.edit(content=f"üì¶ **Kontrakt grupowy: kable**\n{info}", view=self)
            except:
                pass

    @discord.ui.button(label="üì• Zapisz siƒô na kable", style=discord.ButtonStyle.primary)
    async def join_button(self, interaction: discord.Interaction, button: Button):
        kontrakt = active_kable_contracts[self.guild_id]

        if interaction.user.id in kontrakt["uczestnicy"]:
            await interaction.response.send_message("‚ùó Ju≈º jeste≈õ zapisany do kontraktu kable.", ephemeral=True)
            return

        if len(kontrakt["uczestnicy"]) >= 5:
            await interaction.response.send_message("‚ùå Limit 5 uczestnik√≥w zosta≈Ç osiƒÖgniƒôty.", ephemeral=True)
            return

        kontrakt["uczestnicy"].add(interaction.user.id)
        await interaction.response.send_message("‚úÖ Do≈ÇƒÖczy≈Çe≈õ do kontraktu kable.", ephemeral=True)
        await self.update_message(interaction.channel)

    @discord.ui.button(label="üì§ Opu≈õƒá kable", style=discord.ButtonStyle.secondary)
    async def leave_button(self, interaction: discord.Interaction, button: Button):
        kontrakt = active_kable_contracts[self.guild_id]
        if interaction.user.id in kontrakt["uczestnicy"]:
            kontrakt["uczestnicy"].remove(interaction.user.id)
            await interaction.response.send_message("üö™ Opu≈õci≈Çe≈õ kontrakt kable.", ephemeral=True)
        else:
            await interaction.response.send_message("‚ùå Nie jeste≈õ zapisany do tego kontraktu.", ephemeral=True)
        await self.update_message(interaction.channel)

    @discord.ui.button(label="‚úÖ Zako≈Ñcz kontrakt", style=discord.ButtonStyle.success)
    async def finish_button(self, interaction: discord.Interaction, button: Button):
        kontrakt = active_kable_contracts.get(self.guild_id)
        if not kontrakt:
            await interaction.response.send_message("‚ùå Nie znaleziono aktywnego kontraktu.", ephemeral=True)
            return

        role_names = [role.name.lower() for role in interaction.user.roles]
        if interaction.user.id != kontrakt["inicjator"].id and "lider" not in role_names:
            await interaction.response.send_message("‚ùå Tylko inicjator lub u≈ºytkownik z rolƒÖ `Lider` mo≈ºe zako≈Ñczyƒá kontrakt.", ephemeral=True)
            return

        uczestnicy = kontrakt["uczestnicy"]
        for uid in uczestnicy:
            str_uid = str(uid)
            init_user(str_uid)
            user_data[str_uid]["punkty"] += 1
            user_data[str_uid]["kable"] += 1

        with open("dane.json", "w") as f:
            json.dump(user_data, f)

        uczestnicy_mentions = ", ".join([f"<@{uid}>" for uid in uczestnicy])
        embed = discord.Embed(
            title="üì¶ Kontrakt Zako≈Ñczony",
            description=(
                f"Kontrakt **kable** zosta≈Ç zako≈Ñczony przez inicjatora.\n\n"
                f"üë§ **Inicjator:** {kontrakt['inicjator'].mention}\n"
                f"üë• **Uczestnicy:** {uczestnicy_mentions}\n\n"
                f"üéâ Gratulacje dla wszystkich uczestnik√≥w!"
            ),
            color=0xf39c12
        )

        kanal = interaction.channel
        if kontrakt["msg_id"]:
            try:
                await kontrakt["message"].edit(content="", embed=embed, view=None)
            except:
                await kanal.send(embed=embed)
        else:
            await kanal.send(embed=embed)

        del active_kable_contracts[self.guild_id]
        await odswiez_statystyki(interaction.guild)

from discord.ui import View, Button

active_cenna_contracts = {}

class CennaKontraktView(View):
    def __init__(self, interaction, guild_id):
        super().__init__(timeout=None)
        self.guild_id = guild_id
        self.inicjator = interaction.user
        self.kontrakt_msg = None
        active_cenna_contracts[guild_id] = {
            "inicjator": self.inicjator,
            "uczestnicy": set([self.inicjator.id]),
            "msg_id": None,
        }

    async def update_message(self, channel):
        kontrakt = active_cenna_contracts[self.guild_id]
        uczestnicy = kontrakt["uczestnicy"]
        mentions = ", ".join(f"<@{uid}>" for uid in uczestnicy)

        content = (
            f"üî´ **Kontrakt CENNA rozpoczƒôty przez {self.inicjator.mention}!**\n"
            f"üë• Uczestnicy ({len(uczestnicy)}): {mentions}\n"
            f"Kliknij przycisk, aby do≈ÇƒÖczyƒá do kontraktu. Potrzeba minimum 2 os√≥b."
        )

        if self.kontrakt_msg:
            try:
                await self.kontrakt_msg.edit(content=content, view=self)
            except:
                pass

    @discord.ui.button(label="üì• Zapisz siƒô na cennƒÖ", style=discord.ButtonStyle.primary)
    async def join_button(self, interaction: discord.Interaction, button: Button):
        kontrakt = active_cenna_contracts[self.guild_id]
        kontrakt["uczestnicy"].add(interaction.user.id)
        await interaction.response.send_message("‚úÖ Do≈ÇƒÖczy≈Çe≈õ do kontraktu cenna.", ephemeral=True)
        await self.update_message(interaction.channel)

    @discord.ui.button(label="üì§ Opu≈õƒá cennƒÖ", style=discord.ButtonStyle.secondary)
    async def leave_button(self, interaction: discord.Interaction, button: Button):
        kontrakt = active_cenna_contracts[self.guild_id]
        if interaction.user.id in kontrakt["uczestnicy"]:
            kontrakt["uczestnicy"].remove(interaction.user.id)
            await interaction.response.send_message("üö™ Opu≈õci≈Çe≈õ kontrakt cenna.", ephemeral=True)
        else:
            await interaction.response.send_message("‚ùå Nie jeste≈õ zapisany do tego kontraktu.", ephemeral=True)
        await self.update_message(interaction.channel)

    @discord.ui.button(label="‚úÖ Zako≈Ñcz kontrakt", style=discord.ButtonStyle.success)
    async def finish_button(self, interaction: discord.Interaction, button: Button):
        kontrakt = active_cenna_contracts.get(self.guild_id)
        if not kontrakt or kontrakt["inicjator"].id != interaction.user.id:
            await interaction.response.send_message("‚ùå Tylko inicjator mo≈ºe zako≈Ñczyƒá kontrakt.", ephemeral=True)
            return

        uczestnicy = kontrakt["uczestnicy"]
        if len(uczestnicy) < 2:
            await interaction.response.send_message("‚ö†Ô∏è Do zako≈Ñczenia kontraktu **cenna** potrzebne sƒÖ minimum 2 osoby.", ephemeral=True)
            return

        for uid in uczestnicy:
            str_uid = str(uid)
            init_user(str_uid)
            user_data[str_uid]["punkty"] += 2
            user_data[str_uid]["cenna"] += 1
        with open("dane.json", "w") as f:
            json.dump(user_data, f)

        mentions = ", ".join([f"<@{uid}>" for uid in uczestnicy])
        embed = discord.Embed(
            title="üî´ Kontrakt Zako≈Ñczony",
            description=(
                f"Kontrakt **cenna partia** zosta≈Ç zako≈Ñczony przez inicjatora.\n\n"
                f"üë§ **Inicjator:** {kontrakt['inicjator'].mention}\n"
                f"üë• **Uczestnicy:** {mentions}\n\n"
                f"üéâ Gratulacje dla wszystkich uczestnik√≥w!"
            ),
            color=0xff0000
        )

        kanal = interaction.channel
        if kontrakt["msg_id"]:
            try:
                await self.kontrakt_msg.edit(content="", embed=embed, view=None)
            except:
                await kanal.send(embed=embed)
        else:
            await kanal.send(embed=embed)

        del active_cenna_contracts[self.guild_id]
        await odswiez_statystyki(interaction.guild)

active_spisek_contracts = {}

class SpisekKontraktView(View):
    def __init__(self, interaction, guild_id):
        super().__init__(timeout=None)
        self.guild_id = guild_id
        self.inicjator = interaction.user
        self.kontrakt_msg = None
        active_spisek_contracts[guild_id] = {
            "inicjator": self.inicjator,
            "uczestnicy": set([self.inicjator.id]),
            "msg_id": None,
        }

    async def update_message(self, channel):
        kontrakt = active_spisek_contracts[self.guild_id]
        uczestnicy = kontrakt["uczestnicy"]
        mentions = ", ".join(f"<@{uid}>" for uid in uczestnicy)

        content = (
            f"üß† **Rozpoczƒôto kontrakt spisek!**\n"
            f"üë§ Inicjator: {self.inicjator.mention}\n"
            f"üë• Uczestnicy ({len(uczestnicy)}): {mentions}\n"
            f"Zalecane min. 2 osoby."
        )

        if self.kontrakt_msg:
            try:
                await self.kontrakt_msg.edit(content=content, view=self)
            except:
                pass

    @discord.ui.button(label="üß† Do≈ÇƒÖcz do spisku", style=discord.ButtonStyle.primary)
    async def join_spisek(self, interaction: discord.Interaction, button: Button):
        kontrakt = active_spisek_contracts[self.guild_id]
        kontrakt["uczestnicy"].add(interaction.user.id)
        await interaction.response.send_message("‚úÖ Do≈ÇƒÖczy≈Çe≈õ do spisku.", ephemeral=True)
        await self.update_message(interaction.channel)

    @discord.ui.button(label="üö™ Opu≈õƒá spisek", style=discord.ButtonStyle.secondary)
    async def leave_spisek(self, interaction: discord.Interaction, button: Button):
        kontrakt = active_spisek_contracts[self.guild_id]
        if interaction.user.id in kontrakt["uczestnicy"]:
            kontrakt["uczestnicy"].remove(interaction.user.id)
            await interaction.response.send_message("üëã Opu≈õci≈Çe≈õ spisek.", ephemeral=True)
        else:
            await interaction.response.send_message("‚ùå Nie jeste≈õ zapisany do spisku.", ephemeral=True)
        await self.update_message(interaction.channel)

    @discord.ui.button(label="‚úÖ Zako≈Ñcz spisek", style=discord.ButtonStyle.success)
    async def finish_spisek(self, interaction: discord.Interaction, button: Button):
        kontrakt = active_spisek_contracts.get(self.guild_id)
        if not kontrakt or kontrakt["inicjator"].id != interaction.user.id:
            await interaction.response.send_message("‚ùå Tylko inicjator mo≈ºe zako≈Ñczyƒá spisek.", ephemeral=True)
            return

        uczestnicy = kontrakt["uczestnicy"]
        for uid in uczestnicy:
            str_uid = str(uid)
            init_user(str_uid)
            user_data[str_uid]["punkty"] += 1
            user_data[str_uid]["spisek"] += 1
        with open("dane.json", "w") as f:
            json.dump(user_data, f)

        mentions = ", ".join([f"<@{uid}>" for uid in uczestnicy])
        embed = discord.Embed(
            title="üß† Spisek zako≈Ñczony",
            description=(
                f"Kontrakt **spisek** zosta≈Ç zako≈Ñczony przez inicjatora.\n\n"
                f"üë§ **Inicjator:** {kontrakt['inicjator'].mention}\n"
                f"üë• **Uczestnicy:** {mentions}\n\n"
                f"üîé Zalecana liczba uczestnik√≥w: 2+\nüéâ Punkty przyznane!"
            ),
            color=0x9b59b6
        )

        kanal = interaction.channel
        if kontrakt["msg_id"]:
            try:
                await self.kontrakt_msg.edit(content="", embed=embed, view=None)
            except:
                await kanal.send(embed=embed)
        else:
            await kanal.send(embed=embed)

        del active_spisek_contracts[self.guild_id]
        await odswiez_statystyki(interaction.guild)

        kanal = interaction.channel
        if kontrakt["msg_id"]:
            try:
                msg = await kanal.fetch_message(kontrakt["msg_id"])
                await msg.edit(content="", embed=embed, view=None)
            except:
                await kanal.send(embed=embed)
        else:
            await kanal.send(embed=embed)

        del active_spisek_contracts[self.guild_id]
        await odswiez_statystyki(interaction.guild)

from discord.ext import tasks

@tasks.loop(minutes=1)
async def przypomnienie_cenna():
    await bot.wait_until_ready()
    teraz = datetime.now()
    if teraz.hour == 13 and teraz.minute == 0:
        for guild in bot.guilds:
            kanal = discord.utils.get(guild.text_channels, name="üí¨‚îÉchat-rodzinny")
            if kanal:
                await kanal.send(
                    "üì¢ **Godzina 14:00 ‚Äì mo≈ºna dokonywaƒá napad√≥w na biznes!**\n"
                    "Je≈õli kontrakt `cenna` nie jest zamro≈ºony, prosimy o jego wykonanie üí£üíº"
                )

@tasks.loop(minutes=1)
async def ogloszenie_top_usera():
    teraz = datetime.now()
    if teraz.hour == 10 and teraz.minute == 0:
        for guild in bot.guilds:
            kanal = discord.utils.get(guild.text_channels, name="üí¨‚îÉchat-rodzinny")
            if not kanal:
                continue

            if not user_data:
                continue

            top = sorted(user_data.items(), key=lambda x: x[1]["punkty"], reverse=True)
            if not top or top[0][1]["punkty"] <= 0:
                continue

            uid, dane = top[0]
            await kanal.send(
                f"üåü **Dzie≈Ñ dobry!**\n\n"
                f"üèÜ Aktualnym liderem aktywno≈õci jest: <@{uid}> z **{dane['punkty']} punktami**!\n"
                f"Gratulacje za zaanga≈ºowanie! üëè\n\n"
                f"üöÄ Do≈ÇƒÖcz do rywalizacji ‚Äì ka≈ºda aktywno≈õƒá siƒô liczy!"
            )

@tasks.loop(minutes=1)
async def chaos_loop():
    global aktywny_chaos, godzina_chaosu
    teraz = datetime.now(pytz.timezone("Europe/Warsaw"))

    print(f"[CHAOS DEBUG] teraz={teraz.strftime('%H:%M')}, godzina_chaosu={godzina_chaosu}")

    if godzina_chaosu and teraz.hour == godzina_chaosu.hour and teraz.minute == godzina_chaosu.minute:
        if not aktywny_chaos:
            aktywny_chaos = True
            print("[CHAOS] Godzina Chaosu rozpoczƒôta!")

            for guild in bot.guilds:
                kanal = discord.utils.get(guild.text_channels, name="üí¨‚îÉchat-rodzinny")
                if kanal:
                    await kanal.send("@everyone ‚ö†Ô∏è **GODZINA CHAOSU ROZPOCZƒòTA!**\n"
                                     "Wszystkie kontrakty `/kuriergreen`, `/kurierblue` i `/kurierwhite` dajƒÖ **x3 punkty** przez 60 minut!")

            asyncio.create_task(zakonczenie_chaosu())

async def zakonczzenie_chaosu():
    global aktywny_chaos, godzina_chaosu
    await asyncio.sleep(60 * 60)  # 60 minut
    aktywny_chaos = False
    godzina_chaosu = None
    print("[CHAOS] Chaos zako≈Ñczony.")

    for guild in bot.guilds:
        kanal = discord.utils.get(guild.text_channels, name="üí¨‚îÉchat-rodzinny")
        if kanal:
            await kanal.send("‚úÖ **Godzina Chaosu zako≈Ñczona!** Wszystko wraca do normy.")


@tasks.loop(minutes=1)
async def losuj_godzine_chaosu():
    global godzina_chaosu
    teraz = datetime.now(pytz.timezone("Europe/Warsaw"))

    if godzina_chaosu is None:
        losowa_godzina = random.randint(14, 20)  # <-- zmieniony zakres
        losowa_minuta = random.randint(0, 59)
        godzina_chaosu = datetime.strptime(f"{losowa_godzina}:{losowa_minuta}", "%H:%M").time()

        print(f"[CHAOS] Wylosowano: {godzina_chaosu.strftime('%H:%M')}")

        for guild in bot.guilds:
            kanal = discord.utils.get(guild.text_channels, name="üí¨‚îÉchat-rodzinny")
            if kanal:
                await kanal.send(
                    f"üì¢ **Godzina Chaosu** zosta≈Ça wylosowana!\n"
                    f"üé≤ Kontrakty `/kuriergreen`, `/kurierblue` i `/kurierwhite` bƒôdƒÖ liczone x3 "
                    f"w godzinie **{godzina_chaosu.strftime('%H:%M')} - "
                    f"{(datetime.combine(datetime.today(), godzina_chaosu) + timedelta(hours=1)).time().strftime('%H:%M')}**!"
                )
                
@bot.event
async def on_ready():
    await tree.sync()
    print(f"‚úÖ Zalogowano jako {bot.user}")
    print("üì§ Komendy zosta≈Çy zsynchronizowane globalnie.")

    # üåÄ TESTOWE WYMUSZENIE GODZINY CHAOSU
    from datetime import datetime, timedelta
    global godzina_chaosu
    godzina_chaosu = (datetime.now() + timedelta(minutes=1)).time()
    print(f"[DEBUG] Ustawiono testowƒÖ godzinƒô chaosu na: {godzina_chaosu}")

    # üìÇ Wczytaj dane loterii z pliku
    load_lottery_data()
    print("üìÇ Dane loterii wczytane:", lottery_participants)

    # üîÅ Przywr√≥ƒá widoki do istniejƒÖcych wiadomo≈õci loterii
    for guild in bot.guilds:
        if guild.id in lottery_messages:
            bot.add_view(LotteryView(guild.id))

    # üöÄ Uruchom zaplanowane zadania
    przypomnienie_loteria.start()
    uruchom_loterie.start()
    przypomnienie_cenna.start()
    ogloszenie_top_usera.start()
    chaos_loop.start()               
    losuj_godzine_chaosu.start()     

    # üíæ Zapisz dane po synchronizacji
    save_lottery_data()
    await load_kable_data(bot)

@tasks.loop(minutes=10)
async def aktualizuj_wiadomosci_loterii():
    await bot.wait_until_ready()
    for guild in bot.guilds:
        await odswiez_loterie(guild)

from discord.ui import View, Button
from discord import app_commands
import discord
import json

active_capt_events = {}  # {guild_id: {"inicjator": user, "uczestnicy": set, "msg_id": id}}

class CaptView(View):
    def __init__(self, interaction: discord.Interaction):
        super().__init__(timeout=None)
        self.guild_id = interaction.guild.id
        self.inicjator = interaction.user
        active_capt_events[self.guild_id] = {
            "inicjator": self.inicjator,
            "uczestnicy": set([self.inicjator.id]),
            "msg_id": None
        }

    async def update_embed(self, interaction):
        capt = active_capt_events[self.guild_id]
        uczestnicy = capt["uczestnicy"]
        mentions = ", ".join(f"<@{uid}>" for uid in uczestnicy)

        embed = discord.Embed(
            title="‚öîÔ∏è CAPT Rozpoczƒôty",
            description=(
                f"üë§ **Inicjator:** {capt['inicjator'].mention}\n"
                f"üë• **Uczestnicy ({len(uczestnicy)}):** {mentions}\n\n"
                f"üìå Za **capt wygrany** ka≈ºdy uczestnik otrzymuje **2 pkt**, za **przegrany** ‚Äì **1 pkt**."
            ),
            color=0xe74c3c
        )

        try:
            message = await interaction.channel.fetch_message(capt["msg_id"])
            await message.edit(embed=embed, view=self)
        except:
            pass

    @discord.ui.button(label="üì• Do≈ÇƒÖcz do CAPT", style=discord.ButtonStyle.primary)
    async def join(self, interaction: discord.Interaction, button: Button):
        capt = active_capt_events[self.guild_id]
        capt["uczestnicy"].add(interaction.user.id)
        await interaction.response.send_message("‚úÖ Do≈ÇƒÖczy≈Çe≈õ do CAPT.", ephemeral=True)
        await self.update_embed(interaction)

    @discord.ui.button(label="üì§ Opu≈õƒá CAPT", style=discord.ButtonStyle.secondary)
    async def leave(self, interaction: discord.Interaction, button: Button):
        capt = active_capt_events[self.guild_id]
        if interaction.user.id in capt["uczestnicy"]:
            capt["uczestnicy"].remove(interaction.user.id)
            await interaction.response.send_message("üö™ Opu≈õci≈Çe≈õ CAPT.", ephemeral=True)
        else:
            await interaction.response.send_message("‚ùå Nie jeste≈õ zapisany do CAPT.", ephemeral=True)
        await self.update_embed(interaction)

    @discord.ui.button(label="üèÅ CAPT Wygrany", style=discord.ButtonStyle.success)
    async def win(self, interaction: discord.Interaction, button: Button):
        await self.zakonczenie(interaction, wygrana=True)

    @discord.ui.button(label="‚ùå CAPT Przegrany", style=discord.ButtonStyle.danger)
    async def lose(self, interaction: discord.Interaction, button: Button):
        await self.zakonczenie(interaction, wygrana=False)

    async def zakonczenie(self, interaction: discord.Interaction, wygrana: bool):
        capt = active_capt_events.get(self.guild_id)
        if not capt:
            return

        if interaction.user.id != capt["inicjator"].id:
            try:
                await interaction.response.send_message("‚ùå Tylko inicjator mo≈ºe zako≈Ñczyƒá CAPT.", ephemeral=True)
            except discord.NotFound:
                pass
            return

        uczestnicy = capt["uczestnicy"]
        for uid in uczestnicy:
            str_uid = str(uid)
            init_user(str_uid)
            user_data[str_uid]["punkty"] += 2 if wygrana else 1
            user_data[str_uid]["capt"] += 1

        with open("dane.json", "w") as f:
            json.dump(user_data, f)

        wynik = "WYGRANY" if wygrana else "PRZEGRANY"
        kolor = 0x2ecc71 if wygrana else 0xe67e22
        mentions = ", ".join(f"<@{uid}>" for uid in uczestnicy)

        embed = discord.Embed(
            title=f"üéØ CAPT {wynik}",
            description=(
                f"üë§ **Inicjator:** {capt['inicjator'].mention}\n"
                f"üë• **Uczestnicy:** {mentions}\n\n"
                f"üèÅ CAPT zosta≈Ç zako≈Ñczony jako **{wynik}**!\n"
                f"{'ü•á Ka≈ºdy otrzymuje 2 pkt!' if wygrana else 'ü•à Ka≈ºdy otrzymuje 1 pkt!'}"
            ),
            color=kolor
        )

        try:
            message = await interaction.channel.fetch_message(capt["msg_id"])
            await message.edit(content="", embed=embed, view=None)
        except:
            await interaction.channel.send(embed=embed)

        del active_capt_events[self.guild_id]
        await odswiez_statystyki(interaction.guild)

@tree.command(name="capt", description="Rozpocznij akcjƒô CAPT ‚Äì tylko dla Leader√≥w i ZarzƒÖdu")
@app_commands.checks.has_any_role("Leader", "ZarzƒÖd")
async def capt(interaction: discord.Interaction):
    view = CaptView(interaction)
    embed = discord.Embed(
        title="‚öîÔ∏è CAPT Rozpoczƒôty",
        description=(
            f"üë§ **Inicjator:** {interaction.user.mention}\n"
            f"üë• **Uczestnicy (1):** {interaction.user.mention}\n\n"
            f"üìå Za **capt wygrany** ka≈ºdy uczestnik otrzymuje **2 pkt**, za **przegrany** ‚Äì **1 pkt**."
        ),
        color=0xe74c3c
    )
    msg = await interaction.channel.send(embed=embed, view=view)
    active_capt_events[interaction.guild.id]["msg_id"] = msg.id
    await interaction.response.send_message("üì¢ CAPT rozpoczƒôty!", ephemeral=True)

@capt.error
async def capt_error(interaction: discord.Interaction, error):
    if isinstance(error, app_commands.errors.MissingAnyRole):
        await interaction.response.send_message("‚ùå Tylko Leader lub ZarzƒÖd mo≈ºe rozpoczƒÖƒá CAPT.", ephemeral=True)

@tree.command(name="biuroall", description="Wy≈õlij wezwanie na CAPT 5 razy co 5 sekund")
async def biuroall(interaction: discord.Interaction):
    await interaction.response.send_message("üîÅ Wysy≈Çam wezwanie do biura...", ephemeral=True)

    kanal = discord.utils.get(interaction.guild.text_channels, name="üó£‚îÉzbi√≥rka")

    if not kanal:
        await interaction.followup.send("‚ùå Nie znaleziono kana≈Çu üó£‚îÉzbi√≥rka.", ephemeral=True)
        return

    for _ in range(5):
        await kanal.send("@everyone üö® **Rozpoczƒôli≈õmy CAPT!** Wszyscy obowiƒÖzkowo na zbi√≥rkƒô do biura! üèÉ‚Äç‚ôÇÔ∏èüèÉ‚Äç‚ôÄÔ∏è")
        await asyncio.sleep(5)

@tree.command(name="godzinachaosu", description="Zobacz kiedy przypada dzisiejsza Godzina Chaosu")
@app_commands.checks.has_any_role("Leader", "ZarzƒÖd")
async def godzinachaosu(interaction: discord.Interaction):
    global godzina_chaosu, aktywny_chaos

    if aktywny_chaos:
        await interaction.response.send_message("üåÄ **Godzina Chaosu trwa w≈Ça≈õnie teraz!**", ephemeral=True)
    elif godzina_chaosu:
        await interaction.response.send_message(
            f"üïí Dzisiejsza **Godzina Chaosu** zosta≈Ça zaplanowana na: **{godzina_chaosu.strftime('%H:%M')}**",
            ephemeral=True
        )
    else:
        await interaction.response.send_message("‚ùó Godzina Chaosu jeszcze nie zosta≈Ça wylosowana.", ephemeral=True)

@godzinachaosu.error
async def godzinachaosu_error(interaction: discord.Interaction, error):
    if isinstance(error, app_commands.errors.MissingAnyRole):
        await interaction.response.send_message(
            "‚ùå Tylko u≈ºytkownicy z rolƒÖ `Leader` lub `ZarzƒÖd` mogƒÖ sprawdziƒá Godzinƒô Chaosu.",
            ephemeral=True
        )

from discord.ext import tasks

import random
from discord.ext import tasks
from discord.ui import View, Button

lottery_participants = {}  # {guild_id: set(user_ids)}
lottery_messages = {}      # {guild_id: message_id}

class LotteryView(View):
    def __init__(self, guild_id, message_id=None):
        super().__init__(timeout=None)
        self.guild_id = guild_id
        self.message_id = message_id

    @discord.ui.button(label="üéä We≈∫ Udzia≈Ç w Loterii", style=discord.ButtonStyle.success, custom_id="loteria_zapis")
    async def join_lottery(self, interaction: discord.Interaction, button: Button):
        uid = str(interaction.user.id)
        init_user(uid)

        if user_data[uid]["punkty"] < 3:
            await interaction.response.send_message(
                "‚ùå Musisz mieƒá minimum 3 punkty aktywno≈õci, aby wziƒÖƒá udzia≈Ç w loterii.",
                ephemeral=True
            )
            return

        uczestnicy = lottery_participants.setdefault(self.guild_id, set())
        if interaction.user.id in uczestnicy:
            await interaction.response.send_message(
                f"‚ö†Ô∏è Ju≈º jeste≈õ zapisany do loterii!\n"
                f"üéüÔ∏è Aktualna liczba uczestnik√≥w: **{len(uczestnicy)}**",
                ephemeral=True
            )
            return

        uczestnicy.add(interaction.user.id)
        save_lottery_data()
        await interaction.response.send_message(
            f"‚úÖ Zapisano do loterii! üéâ\n"
            f"üéüÔ∏è Obecna liczba uczestnik√≥w: **{len(uczestnicy)}**", ephemeral=True
        )

        await odswiez_loterie(interaction.guild)
        
        @discord.ui.button(label="üîÑ Resetuj Loteriƒô", style=discord.ButtonStyle.danger)
        async def reset_loterii(self, interaction: discord.Interaction, button: Button):
            role_names = [role.name.lower() for role in interaction.user.roles]
            if "lider" not in role_names and "zarzƒÖd" not in role_names:
                await interaction.response.send_message("‚ùå Tylko Lider lub ZarzƒÖd mo≈ºe resetowaƒá loteriƒô.", ephemeral=True)
                return
            await interaction.response.send_modal(ResetLoteriiModal(interaction, self))

    @discord.ui.button(label="üèÅ Zako≈Ñcz Loteriƒô", style=discord.ButtonStyle.primary)
    async def finish_loteria(self, interaction: discord.Interaction, button: Button):
            role_names = [role.name.lower() for role in interaction.user.roles]
            if "lider" not in role_names and "zarzƒÖd" not in role_names:
                await interaction.response.send_message("‚ùå Tylko Lider lub ZarzƒÖd mo≈ºe zako≈Ñczyƒá loteriƒô.", ephemeral=True)
                return
            await interaction.response.send_modal(ZakonczenieLoteriiModal(interaction, self))

@tree.command(name="loteria", description="Utw√≥rz wiadomo≈õƒá loterii z przyciskiem do zapisu")
async def loteria(interaction: discord.Interaction):
    kanal = discord.utils.get(interaction.guild.text_channels, name="üé∞‚îÉloteria")
    if not kanal:
        kanal = await interaction.guild.create_text_channel("üé∞‚îÉloteria")

    uczestnicy = lottery_participants.get(interaction.guild.id, set())
    mentions = ", ".join(f"<@{uid}>" for uid in uczestnicy) if uczestnicy else "Brak zg≈Çosze≈Ñ"

    # Oblicz czas do niedzieli 17:00
    teraz = datetime.now()
    dni_do_niedzieli = (6 - teraz.weekday()) % 7
    next_lottery_time = (teraz + timedelta(days=dni_do_niedzieli)).replace(hour=17, minute=0, second=0)
    if next_lottery_time < teraz:
        next_lottery_time += timedelta(days=7)
    czas_do = next_lottery_time - teraz
    godziny, reszta = divmod(czas_do.total_seconds(), 3600)
    minuty = int(reszta // 60)

    view = LotteryView(interaction.guild.id)
    msg = await kanal.send(
        "**üé∞ LOTERIA TYGODNIOWA!**\n"
        "Kliknij przycisk poni≈ºej, aby zapisaƒá siƒô do loterii!\n"
        "üîí Wymagane minimum 3 punkty aktywno≈õci.\n"
        "üéÅ Nagroda: 50k ‚Äì losowanie w ka≈ºdƒÖ niedzielƒô o 17:00!\n\n"
        f"‚è≥ **Do losowania pozosta≈Ço:** {int(godziny)}h {minuty}min\n\n"
        f"üìã **Aktualni uczestnicy:**\n{mentions}",
        view=view
    )

    lottery_messages[interaction.guild.id] = msg.id
    await interaction.response.send_message("üì® Wiadomo≈õƒá loterii zosta≈Ça wys≈Çana!", ephemeral=True)

async def odswiez_loterie(guild):
    kanal = discord.utils.get(guild.text_channels, name="üé∞‚îÉloteria")
    if not kanal:
        return

    uczestnicy = lottery_participants.get(guild.id, set())
    mentions = ", ".join(f"<@{uid}>" for uid in uczestnicy) if uczestnicy else "Brak zg≈Çosze≈Ñ"

    teraz = datetime.now()
    dni_do_niedzieli = (6 - teraz.weekday()) % 7
    next_lottery_time = (teraz + timedelta(days=dni_do_niedzieli)).replace(hour=17, minute=0, second=0)
    if next_lottery_time < teraz:
        next_lottery_time += timedelta(days=7)
    czas_do = next_lottery_time - teraz
    godziny, reszta = divmod(czas_do.total_seconds(), 3600)
    minuty = int(reszta // 60)

    msg_id = lottery_messages.get(guild.id)
    if not msg_id:
        return

    try:
        msg = await kanal.fetch_message(msg_id)
        view = LotteryView(guild.id, msg_id)
        await msg.edit(
            content=(
                "**üé∞ LOTERIA TYGODNIOWA!**\n"
                "Kliknij przycisk poni≈ºej, aby zapisaƒá siƒô do loterii!\n"
                "üîí Wymagane minimum 3 punkty aktywno≈õci.\n"
                "üéÅ Nagroda: 50k ‚Äì losowanie w ka≈ºdƒÖ niedzielƒô o 17:00!\n\n"
                f"‚è≥ **Do losowania pozosta≈Ço:** {int(godziny)}h {minuty}min\n\n"
                f"üìã **Aktualni uczestnicy:**\n{mentions}"
            ),
            view=view
        )
    except Exception as e:
        print(f"[B≈ÇƒÖd aktualizacji wiadomo≈õci loterii]: {e}")

@tasks.loop(minutes=1)
async def uruchom_loterie():
    teraz = datetime.now()
    if teraz.weekday() == 6 and teraz.hour == 17 and teraz.minute == 0:
        for guild in bot.guilds:
            kanal_loteria = discord.utils.get(guild.text_channels, name="üé∞‚îÉloteria")
            kanal_chat = discord.utils.get(guild.text_channels, name="üí¨‚îÉchat-rodzinny")

            uczestnicy = lottery_participants.get(guild.id, set())
            if not uczestnicy:
                if kanal_loteria:
                    await kanal_loteria.send("üé∞ Loteria zako≈Ñczona ‚Äì brak uczestnik√≥w spe≈ÇniajƒÖcych wymagania.")
                continue

            zwyciezca = random.choice(list(uczestnicy))
            wynik = (
                f"üéâ **WYNIKI LOTERII!**\n"
                f"Nagrodƒô **50k** zgarnia: <@{zwyciezca}>!\n"
                f"Gratulacje i do zobaczenia za tydzie≈Ñ! ü§ë"
            )

            if kanal_loteria:
                await kanal_loteria.send(wynik)
            if kanal_chat:
                await kanal_chat.send(f"@everyone {wynik}")

@tasks.loop(minutes=1)
async def przypomnienie_loteria():
    teraz = datetime.now()
    if teraz.hour == 16 and teraz.minute == 0:
        for guild in bot.guilds:
            kanal = discord.utils.get(guild.text_channels, name="üí¨‚îÉchat-rodzinny")
            if not kanal:
                continue

            dni_do_niedzieli = (6 - teraz.weekday()) % 7
            next_lottery_time = (teraz + timedelta(days=dni_do_niedzieli)).replace(hour=17, minute=0, second=0)
            if next_lottery_time < teraz:
                next_lottery_time += timedelta(days=7)
            czas_do = next_lottery_time - teraz
            godziny, reszta = divmod(czas_do.total_seconds(), 3600)
            minuty = int(reszta // 60)

            await kanal.send(
                f"@everyone üé∞ **Loteria Tygodniowa** trwa!\n"
                f"üìã Do rozstrzygniƒôcia pozosta≈Ço: **{int(godziny)}h {minuty}min**\n"
                f"Kliknij przycisk w kanale <#üé∞‚îÉloteria> i we≈∫ udzia≈Ç ‚Äì je≈õli masz minimum 3 punkty aktywno≈õci! üçÄüí∏"
            )

import discord
from discord.ext import commands
from discord import app_commands
from datetime import datetime, timedelta

class WystawMnieView(discord.ui.View):
    def __init__(self, bot):
        super().__init__(timeout=None)
        self.bot = bot
        self.zgloszeni = {}  # user_id: datetime

    def format_lista(self):
        if not self.zgloszeni:
            return "*Brak zg≈Çoszonych.*"
        lines = ["**üìã Aktualna lista zg≈Çoszonych na capta:**\n"]
        for idx, (user_id, czas) in enumerate(self.zgloszeni.items(), start=1):
            user = self.bot.get_user(user_id)
            czas_str = czas.strftime("%H:%M")
            lines.append(f"`{idx}.` **{user.mention}** ‚è∞ {czas_str}")
        lines.append("\n‚ùó Mo≈ºesz siƒô wypisaƒá tylko przez 15 minut od zg≈Çoszenia.")
        lines.append("üîÑ Lista aktualizuje siƒô automatycznie.")
        return "\n".join(lines)

    async def update_message(self, interaction):
        embed = discord.Embed(title="üéØ Wystawienie na Capta", description=self.format_lista(), color=0x2ecc71)
        await interaction.message.edit(embed=embed, view=self)

    @discord.ui.button(label="‚úÖ Wystaw mnie", style=discord.ButtonStyle.success)
    async def wystaw(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.zgloszeni[interaction.user.id] = datetime.now()
        await self.update_message(interaction)
        await interaction.response.defer()

    @discord.ui.button(label="‚ùå Wypisz mnie", style=discord.ButtonStyle.danger)
    async def wypisz(self, interaction: discord.Interaction, button: discord.ui.Button):
        now = datetime.now()
        zapisany = self.zgloszeni.get(interaction.user.id)

        if not zapisany:
            await interaction.response.send_message("Nie jeste≈õ zapisany.", ephemeral=True)
            return

        if now - zapisany > timedelta(minutes=15):
            await interaction.response.send_message("Minƒô≈Ço ponad 15 minut od zg≈Çoszenia. Nie mo≈ºesz siƒô ju≈º wypisaƒá.", ephemeral=True)
            return

        del self.zgloszeni[interaction.user.id]
        await self.update_message(interaction)
        await interaction.response.defer()


class WystawMnie(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @app_commands.command(name="wystawmnie", description="Zapisz siƒô na capta z dynamicznƒÖ listƒÖ zg≈Çosze≈Ñ")
    async def wystawmnie(self, interaction: discord.Interaction):
        view = WystawMnieView(self.bot)
        embed = discord.Embed(title="üéØ Wystawienie na Capta", description=view.format_lista(), color=0x2ecc71)
        await interaction.response.send_message(embed=embed, view=view)

async def setup(bot):
    await bot.add_cog(WystawMnie(bot))

@green.error
@blue.error
@white.error
async def cooldown_error(interaction: discord.Interaction, error):
    if isinstance(error, commands.CommandOnCooldown):
        remaining = round(error.retry_after)
        minutes, seconds = divmod(remaining, 60)
        await interaction.response.send_message(
            f"‚è≥ Mo≈ºesz u≈ºyƒá tej komendy ponownie za **{int(minutes)}m {int(seconds)}s**.",
            ephemeral=True
        )

class ResetLoteriiModal(discord.ui.Modal, title="Reset Loterii"):
    kod = discord.ui.TextInput(label="Wpisz has≈Ço", placeholder="np. LoteriaHeaven", required=True)

    def __init__(self, interaction, view):
        super().__init__()
        self.interaction = interaction
        self.view = view

    async def on_submit(self, interaction: discord.Interaction):
        if self.kod.value != "LoteriaHeaven":
            await interaction.response.send_message("‚ùå Niepoprawny kod resetu.", ephemeral=True)
            return

        guild_id = self.interaction.guild.id
        user = interaction.user
        czas = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

        lottery_participants[guild_id] = set()
        if guild_id in lottery_messages:
            del lottery_messages[guild_id]
        save_lottery_data()

        kanal = discord.utils.get(self.interaction.guild.text_channels, name="üé∞‚îÉloteria")
        if kanal:
            async for msg in kanal.history(limit=20):
                if msg.author == self.interaction.client.user:
                    await msg.delete()

        await loteria(self.interaction)
        await interaction.response.send_message("‚úÖ Loteria zosta≈Ça zresetowana!", ephemeral=True)

        print(f"[{czas}] üîÅ RESET LOTERII przez {user.name} ({user.id}) na serwerze {self.interaction.guild.name}")


import os
import asyncio

async def main():
    async with bot:
        await bot.load_extension("afk")  # za≈Çaduj cog afk.py
        await bot.start(os.getenv("DISCORD_TOKEN"))

asyncio.run(main())

